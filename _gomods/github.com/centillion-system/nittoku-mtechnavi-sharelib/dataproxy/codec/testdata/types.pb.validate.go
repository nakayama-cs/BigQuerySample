// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: types.proto

package testdata

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ScalarTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScalarTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScalarTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScalarTypesMultiError, or
// nil if none found.
func (m *ScalarTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *ScalarTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Double_

	// no validation rules for Float_

	// no validation rules for Int32_

	// no validation rules for Int64_

	// no validation rules for Uint32_

	// no validation rules for Uint64_

	// no validation rules for Sint32_

	// no validation rules for Sint64_

	// no validation rules for Fixed32_

	// no validation rules for Fixed64_

	// no validation rules for Sfixed32_

	// no validation rules for Sfixed64_

	// no validation rules for Bool_

	// no validation rules for String_

	// no validation rules for Bytes_

	if len(errors) > 0 {
		return ScalarTypesMultiError(errors)
	}

	return nil
}

// ScalarTypesMultiError is an error wrapping multiple validation errors
// returned by ScalarTypes.ValidateAll() if the designated constraints aren't met.
type ScalarTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScalarTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScalarTypesMultiError) AllErrors() []error { return m }

// ScalarTypesValidationError is the validation error returned by
// ScalarTypes.Validate if the designated constraints aren't met.
type ScalarTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScalarTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScalarTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScalarTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScalarTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScalarTypesValidationError) ErrorName() string { return "ScalarTypesValidationError" }

// Error satisfies the builtin error interface
func (e ScalarTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScalarTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScalarTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScalarTypesValidationError{}

// Validate checks the field values on RepeatedTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepeatedTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepeatedTypes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepeatedTypesMultiError, or
// nil if none found.
func (m *RepeatedTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *RepeatedTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RepeatedTypesMultiError(errors)
	}

	return nil
}

// RepeatedTypesMultiError is an error wrapping multiple validation errors
// returned by RepeatedTypes.ValidateAll() if the designated constraints
// aren't met.
type RepeatedTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepeatedTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepeatedTypesMultiError) AllErrors() []error { return m }

// RepeatedTypesValidationError is the validation error returned by
// RepeatedTypes.Validate if the designated constraints aren't met.
type RepeatedTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepeatedTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepeatedTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepeatedTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepeatedTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepeatedTypesValidationError) ErrorName() string { return "RepeatedTypesValidationError" }

// Error satisfies the builtin error interface
func (e RepeatedTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepeatedTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepeatedTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepeatedTypesValidationError{}

// Validate checks the field values on MapTypes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MapTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MapTypesMultiError, or nil
// if none found.
func (m *MapTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *MapTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MapStringDouble_

	// no validation rules for MapStringFloat_

	// no validation rules for MapStringInt32_

	// no validation rules for MapStringInt64_

	// no validation rules for MapStringUint32_

	// no validation rules for MapStringUint64_

	// no validation rules for MapStringSint32_

	// no validation rules for MapStringSint64_

	// no validation rules for MapStringFixed32_

	// no validation rules for MapStringFixed64_

	// no validation rules for MapStringSfixed32_

	// no validation rules for MapStringSfixed64_

	// no validation rules for MapStringBool_

	// no validation rules for MapStringString_

	// no validation rules for MapStringBytes_

	{
		sorted_keys := make([]string, len(m.GetMapStringMessage_()))
		i := 0
		for key := range m.GetMapStringMessage_() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMapStringMessage_()[key]
			_ = val

			// no validation rules for MapStringMessage_[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapStringMessage_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapStringMessage_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapTypesValidationError{
						field:  fmt.Sprintf("MapStringMessage_[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for NilMapStringString_

	// no validation rules for MapInt32Double_

	// no validation rules for MapInt32Float_

	// no validation rules for MapInt32Int32_

	// no validation rules for MapInt32Int64_

	// no validation rules for MapInt32Uint32_

	// no validation rules for MapInt32Uint64_

	// no validation rules for MapInt32Sint32_

	// no validation rules for MapInt32Sint64_

	// no validation rules for MapInt32Fixed32_

	// no validation rules for MapInt32Fixed64_

	// no validation rules for MapInt32Sfixed32_

	// no validation rules for MapInt32Sfixed64_

	// no validation rules for MapInt32Bool_

	// no validation rules for MapInt32String_

	// no validation rules for MapInt32Bytes_

	{
		sorted_keys := make([]int32, len(m.GetMapInt32Message_()))
		i := 0
		for key := range m.GetMapInt32Message_() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMapInt32Message_()[key]
			_ = val

			// no validation rules for MapInt32Message_[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapInt32Message_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapInt32Message_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapTypesValidationError{
						field:  fmt.Sprintf("MapInt32Message_[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for NilMapInt32String_

	// no validation rules for MapInt64Double_

	// no validation rules for MapInt64Float_

	// no validation rules for MapInt64Int32_

	// no validation rules for MapInt64Int64_

	// no validation rules for MapInt64Uint32_

	// no validation rules for MapInt64Uint64_

	// no validation rules for MapInt64Sint32_

	// no validation rules for MapInt64Sint64_

	// no validation rules for MapInt64Fixed32_

	// no validation rules for MapInt64Fixed64_

	// no validation rules for MapInt64Sfixed32_

	// no validation rules for MapInt64Sfixed64_

	// no validation rules for MapInt64Bool_

	// no validation rules for MapInt64String_

	// no validation rules for MapInt64Bytes_

	{
		sorted_keys := make([]int64, len(m.GetMapInt64Message_()))
		i := 0
		for key := range m.GetMapInt64Message_() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMapInt64Message_()[key]
			_ = val

			// no validation rules for MapInt64Message_[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapInt64Message_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapInt64Message_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapTypesValidationError{
						field:  fmt.Sprintf("MapInt64Message_[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for NilMapInt64String_

	// no validation rules for MapUint32Double_

	// no validation rules for MapUint32Float_

	// no validation rules for MapUint32Int32_

	// no validation rules for MapUint32Int64_

	// no validation rules for MapUint32Uint32_

	// no validation rules for MapUint32Uint64_

	// no validation rules for MapUint32Sint32_

	// no validation rules for MapUint32Sint64_

	// no validation rules for MapUint32Fixed32_

	// no validation rules for MapUint32Fixed64_

	// no validation rules for MapUint32Sfixed32_

	// no validation rules for MapUint32Sfixed64_

	// no validation rules for MapUint32Bool_

	// no validation rules for MapUint32String_

	// no validation rules for MapUint32Bytes_

	{
		sorted_keys := make([]uint32, len(m.GetMapUint32Message_()))
		i := 0
		for key := range m.GetMapUint32Message_() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMapUint32Message_()[key]
			_ = val

			// no validation rules for MapUint32Message_[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapUint32Message_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapUint32Message_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapTypesValidationError{
						field:  fmt.Sprintf("MapUint32Message_[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for NilMapUint32String_

	// no validation rules for MapUint64Double_

	// no validation rules for MapUint64Float_

	// no validation rules for MapUint64Int32_

	// no validation rules for MapUint64Int64_

	// no validation rules for MapUint64Uint32_

	// no validation rules for MapUint64Uint64_

	// no validation rules for MapUint64Sint32_

	// no validation rules for MapUint64Sint64_

	// no validation rules for MapUint64Fixed32_

	// no validation rules for MapUint64Fixed64_

	// no validation rules for MapUint64Sfixed32_

	// no validation rules for MapUint64Sfixed64_

	// no validation rules for MapUint64Bool_

	// no validation rules for MapUint64String_

	// no validation rules for MapUint64Bytes_

	{
		sorted_keys := make([]uint64, len(m.GetMapUint64Message_()))
		i := 0
		for key := range m.GetMapUint64Message_() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMapUint64Message_()[key]
			_ = val

			// no validation rules for MapUint64Message_[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapUint64Message_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapTypesValidationError{
							field:  fmt.Sprintf("MapUint64Message_[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapTypesValidationError{
						field:  fmt.Sprintf("MapUint64Message_[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for NilMapUint64String_

	if len(errors) > 0 {
		return MapTypesMultiError(errors)
	}

	return nil
}

// MapTypesMultiError is an error wrapping multiple validation errors returned
// by MapTypes.ValidateAll() if the designated constraints aren't met.
type MapTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapTypesMultiError) AllErrors() []error { return m }

// MapTypesValidationError is the validation error returned by
// MapTypes.Validate if the designated constraints aren't met.
type MapTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapTypesValidationError) ErrorName() string { return "MapTypesValidationError" }

// Error satisfies the builtin error interface
func (e MapTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapTypesValidationError{}

// Validate checks the field values on OneOfTypes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OneOfTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OneOfTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OneOfTypesMultiError, or
// nil if none found.
func (m *OneOfTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *OneOfTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.TestOneof.(type) {

	case *OneOfTypes_Message1:

		if all {
			switch v := interface{}(m.GetMessage1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OneOfTypesValidationError{
						field:  "Message1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OneOfTypesValidationError{
						field:  "Message1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OneOfTypesValidationError{
					field:  "Message1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OneOfTypes_Message2:

		if all {
			switch v := interface{}(m.GetMessage2()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OneOfTypesValidationError{
						field:  "Message2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OneOfTypesValidationError{
						field:  "Message2",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage2()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OneOfTypesValidationError{
					field:  "Message2",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OneOfTypesMultiError(errors)
	}

	return nil
}

// OneOfTypesMultiError is an error wrapping multiple validation errors
// returned by OneOfTypes.ValidateAll() if the designated constraints aren't met.
type OneOfTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OneOfTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OneOfTypesMultiError) AllErrors() []error { return m }

// OneOfTypesValidationError is the validation error returned by
// OneOfTypes.Validate if the designated constraints aren't met.
type OneOfTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OneOfTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OneOfTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OneOfTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OneOfTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OneOfTypesValidationError) ErrorName() string { return "OneOfTypesValidationError" }

// Error satisfies the builtin error interface
func (e OneOfTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOneOfTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OneOfTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OneOfTypesValidationError{}

// Validate checks the field values on EnumTypes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnumTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnumTypesMultiError, or nil
// if none found.
func (m *EnumTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RootEnum1

	// no validation rules for ScopedEnum1

	if len(errors) > 0 {
		return EnumTypesMultiError(errors)
	}

	return nil
}

// EnumTypesMultiError is an error wrapping multiple validation errors returned
// by EnumTypes.ValidateAll() if the designated constraints aren't met.
type EnumTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumTypesMultiError) AllErrors() []error { return m }

// EnumTypesValidationError is the validation error returned by
// EnumTypes.Validate if the designated constraints aren't met.
type EnumTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumTypesValidationError) ErrorName() string { return "EnumTypesValidationError" }

// Error satisfies the builtin error interface
func (e EnumTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumTypesValidationError{}

// Validate checks the field values on RootMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RootMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RootMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RootMessageMultiError, or
// nil if none found.
func (m *RootMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *RootMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for X

	if all {
		switch v := interface{}(m.GetSharedProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RootMessageValidationError{
					field:  "SharedProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RootMessageValidationError{
					field:  "SharedProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSharedProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RootMessageValidationError{
				field:  "SharedProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for DeletedAt

	if len(errors) > 0 {
		return RootMessageMultiError(errors)
	}

	return nil
}

// RootMessageMultiError is an error wrapping multiple validation errors
// returned by RootMessage.ValidateAll() if the designated constraints aren't met.
type RootMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RootMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RootMessageMultiError) AllErrors() []error { return m }

// RootMessageValidationError is the validation error returned by
// RootMessage.Validate if the designated constraints aren't met.
type RootMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RootMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RootMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RootMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RootMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RootMessageValidationError) ErrorName() string { return "RootMessageValidationError" }

// Error satisfies the builtin error interface
func (e RootMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRootMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RootMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RootMessageValidationError{}

// Validate checks the field values on MessageTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MessageTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MessageTypes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MessageTypesMultiError, or
// nil if none found.
func (m *MessageTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *MessageTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRootMessage1()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageTypesValidationError{
					field:  "RootMessage1",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageTypesValidationError{
					field:  "RootMessage1",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootMessage1()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageTypesValidationError{
				field:  "RootMessage1",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRootMessage2() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageTypesValidationError{
						field:  fmt.Sprintf("RootMessage2[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageTypesValidationError{
						field:  fmt.Sprintf("RootMessage2[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageTypesValidationError{
					field:  fmt.Sprintf("RootMessage2[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetScopedMessage1()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageTypesValidationError{
					field:  "ScopedMessage1",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageTypesValidationError{
					field:  "ScopedMessage1",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScopedMessage1()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageTypesValidationError{
				field:  "ScopedMessage1",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetScopedMessage2() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MessageTypesValidationError{
						field:  fmt.Sprintf("ScopedMessage2[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MessageTypesValidationError{
						field:  fmt.Sprintf("ScopedMessage2[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MessageTypesValidationError{
					field:  fmt.Sprintf("ScopedMessage2[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MessageTypesMultiError(errors)
	}

	return nil
}

// MessageTypesMultiError is an error wrapping multiple validation errors
// returned by MessageTypes.ValidateAll() if the designated constraints aren't met.
type MessageTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageTypesMultiError) AllErrors() []error { return m }

// MessageTypesValidationError is the validation error returned by
// MessageTypes.Validate if the designated constraints aren't met.
type MessageTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageTypesValidationError) ErrorName() string { return "MessageTypesValidationError" }

// Error satisfies the builtin error interface
func (e MessageTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessageTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageTypesValidationError{}

// Validate checks the field values on WellKnownTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WellKnownTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WellKnownTypes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WellKnownTypesMultiError,
// or nil if none found.
func (m *WellKnownTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *WellKnownTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEmpty()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WellKnownTypesValidationError{
					field:  "Empty",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WellKnownTypesValidationError{
					field:  "Empty",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmpty()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WellKnownTypesValidationError{
				field:  "Empty",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WellKnownTypesMultiError(errors)
	}

	return nil
}

// WellKnownTypesMultiError is an error wrapping multiple validation errors
// returned by WellKnownTypes.ValidateAll() if the designated constraints
// aren't met.
type WellKnownTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WellKnownTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WellKnownTypesMultiError) AllErrors() []error { return m }

// WellKnownTypesValidationError is the validation error returned by
// WellKnownTypes.Validate if the designated constraints aren't met.
type WellKnownTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WellKnownTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WellKnownTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WellKnownTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WellKnownTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WellKnownTypesValidationError) ErrorName() string { return "WellKnownTypesValidationError" }

// Error satisfies the builtin error interface
func (e WellKnownTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWellKnownTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WellKnownTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WellKnownTypesValidationError{}

// Validate checks the field values on ValidateTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ValidateTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidateTypes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ValidateTypesMultiError, or
// nil if none found.
func (m *ValidateTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidateTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateEmail(m.GetX()); err != nil {
		err = ValidateTypesValidationError{
			field:  "X",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ValidateTypesMultiError(errors)
	}

	return nil
}

func (m *ValidateTypes) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *ValidateTypes) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// ValidateTypesMultiError is an error wrapping multiple validation errors
// returned by ValidateTypes.ValidateAll() if the designated constraints
// aren't met.
type ValidateTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateTypesMultiError) AllErrors() []error { return m }

// ValidateTypesValidationError is the validation error returned by
// ValidateTypes.Validate if the designated constraints aren't met.
type ValidateTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateTypesValidationError) ErrorName() string { return "ValidateTypesValidationError" }

// Error satisfies the builtin error interface
func (e ValidateTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateTypesValidationError{}

// Validate checks the field values on VisibilityTypes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VisibilityTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VisibilityTypes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VisibilityTypesMultiError, or nil if none found.
func (m *VisibilityTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *VisibilityTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Private1

	// no validation rules for Private2

	// no validation rules for Granted

	// no validation rules for Public

	if len(errors) > 0 {
		return VisibilityTypesMultiError(errors)
	}

	return nil
}

// VisibilityTypesMultiError is an error wrapping multiple validation errors
// returned by VisibilityTypes.ValidateAll() if the designated constraints
// aren't met.
type VisibilityTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VisibilityTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VisibilityTypesMultiError) AllErrors() []error { return m }

// VisibilityTypesValidationError is the validation error returned by
// VisibilityTypes.Validate if the designated constraints aren't met.
type VisibilityTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VisibilityTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VisibilityTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VisibilityTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VisibilityTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VisibilityTypesValidationError) ErrorName() string { return "VisibilityTypesValidationError" }

// Error satisfies the builtin error interface
func (e VisibilityTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVisibilityTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VisibilityTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VisibilityTypesValidationError{}

// Validate checks the field values on IndexTypes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IndexTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndexTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IndexTypesMultiError, or
// nil if none found.
func (m *IndexTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *IndexTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Double_

	// no validation rules for Float_

	// no validation rules for Int32_

	// no validation rules for Int64_

	// no validation rules for Uint32_

	// no validation rules for Uint64_

	// no validation rules for Sint32_

	// no validation rules for Sint64_

	// no validation rules for Fixed32_

	// no validation rules for Fixed64_

	// no validation rules for Sfixed32_

	// no validation rules for Sfixed64_

	// no validation rules for Bool_

	// no validation rules for String_

	// no validation rules for Enum_

	if all {
		switch v := interface{}(m.GetMessage_()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IndexTypesValidationError{
					field:  "Message_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IndexTypesValidationError{
					field:  "Message_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessage_()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IndexTypesValidationError{
				field:  "Message_",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNestedMessage_()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IndexTypesValidationError{
					field:  "NestedMessage_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IndexTypesValidationError{
					field:  "NestedMessage_",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNestedMessage_()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IndexTypesValidationError{
				field:  "NestedMessage_",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MapStringString_

	// no validation rules for MapInt64String_

	for idx, item := range m.GetRepeatedMessage_() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndexTypesValidationError{
						field:  fmt.Sprintf("RepeatedMessage_[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndexTypesValidationError{
						field:  fmt.Sprintf("RepeatedMessage_[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndexTypesValidationError{
					field:  fmt.Sprintf("RepeatedMessage_[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IndexTypesId

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for DeletedAt

	if len(errors) > 0 {
		return IndexTypesMultiError(errors)
	}

	return nil
}

// IndexTypesMultiError is an error wrapping multiple validation errors
// returned by IndexTypes.ValidateAll() if the designated constraints aren't met.
type IndexTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndexTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndexTypesMultiError) AllErrors() []error { return m }

// IndexTypesValidationError is the validation error returned by
// IndexTypes.Validate if the designated constraints aren't met.
type IndexTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndexTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndexTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndexTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndexTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndexTypesValidationError) ErrorName() string { return "IndexTypesValidationError" }

// Error satisfies the builtin error interface
func (e IndexTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndexTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndexTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndexTypesValidationError{}

// Validate checks the field values on MessageTypes_ScopedMessage with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MessageTypes_ScopedMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MessageTypes_ScopedMessage with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MessageTypes_ScopedMessageMultiError, or nil if none found.
func (m *MessageTypes_ScopedMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *MessageTypes_ScopedMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Y

	if len(errors) > 0 {
		return MessageTypes_ScopedMessageMultiError(errors)
	}

	return nil
}

// MessageTypes_ScopedMessageMultiError is an error wrapping multiple
// validation errors returned by MessageTypes_ScopedMessage.ValidateAll() if
// the designated constraints aren't met.
type MessageTypes_ScopedMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageTypes_ScopedMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageTypes_ScopedMessageMultiError) AllErrors() []error { return m }

// MessageTypes_ScopedMessageValidationError is the validation error returned
// by MessageTypes_ScopedMessage.Validate if the designated constraints aren't met.
type MessageTypes_ScopedMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageTypes_ScopedMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageTypes_ScopedMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageTypes_ScopedMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageTypes_ScopedMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageTypes_ScopedMessageValidationError) ErrorName() string {
	return "MessageTypes_ScopedMessageValidationError"
}

// Error satisfies the builtin error interface
func (e MessageTypes_ScopedMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessageTypes_ScopedMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageTypes_ScopedMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageTypes_ScopedMessageValidationError{}
