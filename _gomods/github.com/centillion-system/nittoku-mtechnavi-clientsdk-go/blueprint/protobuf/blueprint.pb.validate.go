// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: blueprint.proto

package protobuf

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on TransactionUnit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransactionUnit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionUnit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionUnitMultiError, or nil if none found.
func (m *TransactionUnit) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionUnit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionUnitId

	// no validation rules for TransactionUnitCode

	// no validation rules for DisplayNameLang

	if all {
		switch v := interface{}(m.GetBlueprintReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "BlueprintReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "BlueprintReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlueprintReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionUnitValidationError{
				field:  "BlueprintReference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCatalogReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "CatalogReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "CatalogReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCatalogReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionUnitValidationError{
				field:  "CatalogReference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQuantityUnit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "QuantityUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "QuantityUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuantityUnit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionUnitValidationError{
				field:  "QuantityUnit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetProcesss() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionUnitValidationError{
						field:  fmt.Sprintf("Processs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionUnitValidationError{
						field:  fmt.Sprintf("Processs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionUnitValidationError{
					field:  fmt.Sprintf("Processs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCategory1()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "Category1",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "Category1",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategory1()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionUnitValidationError{
				field:  "Category1",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCategory2()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "Category2",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "Category2",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategory2()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionUnitValidationError{
				field:  "Category2",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCategory3()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "Category3",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "Category3",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategory3()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionUnitValidationError{
				field:  "Category3",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ContactMatter

	if all {
		switch v := interface{}(m.GetUsable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "Usable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionUnitValidationError{
					field:  "Usable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionUnitValidationError{
				field:  "Usable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TransactionUnitNumber

	// no validation rules for DeletedAt

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return TransactionUnitMultiError(errors)
	}

	return nil
}

// TransactionUnitMultiError is an error wrapping multiple validation errors
// returned by TransactionUnit.ValidateAll() if the designated constraints
// aren't met.
type TransactionUnitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionUnitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionUnitMultiError) AllErrors() []error { return m }

// TransactionUnitValidationError is the validation error returned by
// TransactionUnit.Validate if the designated constraints aren't met.
type TransactionUnitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionUnitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionUnitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionUnitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionUnitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionUnitValidationError) ErrorName() string { return "TransactionUnitValidationError" }

// Error satisfies the builtin error interface
func (e TransactionUnitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionUnit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionUnitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionUnitValidationError{}

// Validate checks the field values on BlueprintReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BlueprintReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlueprintReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlueprintReferenceMultiError, or nil if none found.
func (m *BlueprintReference) ValidateAll() error {
	return m.validate(true)
}

func (m *BlueprintReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BlueprintNumber

	// no validation rules for BranchNumber

	// no validation rules for Revision

	if len(errors) > 0 {
		return BlueprintReferenceMultiError(errors)
	}

	return nil
}

// BlueprintReferenceMultiError is an error wrapping multiple validation errors
// returned by BlueprintReference.ValidateAll() if the designated constraints
// aren't met.
type BlueprintReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlueprintReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlueprintReferenceMultiError) AllErrors() []error { return m }

// BlueprintReferenceValidationError is the validation error returned by
// BlueprintReference.Validate if the designated constraints aren't met.
type BlueprintReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlueprintReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlueprintReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlueprintReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlueprintReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlueprintReferenceValidationError) ErrorName() string {
	return "BlueprintReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e BlueprintReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlueprintReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlueprintReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlueprintReferenceValidationError{}

// Validate checks the field values on CatalogReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CatalogReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CatalogReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CatalogReferenceMultiError, or nil if none found.
func (m *CatalogReference) ValidateAll() error {
	return m.validate(true)
}

func (m *CatalogReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ModelNumber

	// no validation rules for Manufacture

	if len(errors) > 0 {
		return CatalogReferenceMultiError(errors)
	}

	return nil
}

// CatalogReferenceMultiError is an error wrapping multiple validation errors
// returned by CatalogReference.ValidateAll() if the designated constraints
// aren't met.
type CatalogReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CatalogReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CatalogReferenceMultiError) AllErrors() []error { return m }

// CatalogReferenceValidationError is the validation error returned by
// CatalogReference.Validate if the designated constraints aren't met.
type CatalogReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CatalogReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CatalogReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CatalogReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CatalogReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CatalogReferenceValidationError) ErrorName() string { return "CatalogReferenceValidationError" }

// Error satisfies the builtin error interface
func (e CatalogReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCatalogReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CatalogReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CatalogReferenceValidationError{}

// Validate checks the field values on Blueprint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Blueprint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Blueprint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlueprintMultiError, or nil
// if none found.
func (m *Blueprint) ValidateAll() error {
	return m.validate(true)
}

func (m *Blueprint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BlueprintId

	// no validation rules for BlueprintNumber

	// no validation rules for BranchNumber

	// no validation rules for Revision

	// no validation rules for DisplayNameLang

	if all {
		switch v := interface{}(m.GetBlueprintContentType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "BlueprintContentType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "BlueprintContentType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlueprintContentType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlueprintValidationError{
				field:  "BlueprintContentType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCategory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlueprintValidationError{
				field:  "Category",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DesignCompany

	// no validation rules for ConfidentialLevel

	// no validation rules for Remarks

	if all {
		switch v := interface{}(m.GetRevisionProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "RevisionProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "RevisionProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRevisionProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlueprintValidationError{
				field:  "RevisionProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBlueprintFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "BlueprintFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "BlueprintFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlueprintFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlueprintValidationError{
				field:  "BlueprintFile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUsable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "Usable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "Usable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlueprintValidationError{
				field:  "Usable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBlueprintStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "BlueprintStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlueprintValidationError{
					field:  "BlueprintStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlueprintStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlueprintValidationError{
				field:  "BlueprintStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DeletedAt

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	switch m.BlueprintContent.(type) {

	case *Blueprint_PartDrawingProperties:

		if all {
			switch v := interface{}(m.GetPartDrawingProperties()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlueprintValidationError{
						field:  "PartDrawingProperties",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlueprintValidationError{
						field:  "PartDrawingProperties",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPartDrawingProperties()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlueprintValidationError{
					field:  "PartDrawingProperties",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Blueprint_AssemblyDrawingProperties:

		if all {
			switch v := interface{}(m.GetAssemblyDrawingProperties()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlueprintValidationError{
						field:  "AssemblyDrawingProperties",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlueprintValidationError{
						field:  "AssemblyDrawingProperties",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAssemblyDrawingProperties()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlueprintValidationError{
					field:  "AssemblyDrawingProperties",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BlueprintMultiError(errors)
	}

	return nil
}

// BlueprintMultiError is an error wrapping multiple validation errors returned
// by Blueprint.ValidateAll() if the designated constraints aren't met.
type BlueprintMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlueprintMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlueprintMultiError) AllErrors() []error { return m }

// BlueprintValidationError is the validation error returned by
// Blueprint.Validate if the designated constraints aren't met.
type BlueprintValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlueprintValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlueprintValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlueprintValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlueprintValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlueprintValidationError) ErrorName() string { return "BlueprintValidationError" }

// Error satisfies the builtin error interface
func (e BlueprintValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlueprint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlueprintValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlueprintValidationError{}

// Validate checks the field values on BlueprintStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BlueprintStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlueprintStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlueprintStatusMultiError, or nil if none found.
func (m *BlueprintStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *BlueprintStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlueprintStatusValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlueprintStatusValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlueprintStatusValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCategory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlueprintStatusValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlueprintStatusValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlueprintStatusValidationError{
				field:  "Category",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlueprintStatusValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlueprintStatusValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlueprintStatusValidationError{
				field:  "Detail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlueprintStatusMultiError(errors)
	}

	return nil
}

// BlueprintStatusMultiError is an error wrapping multiple validation errors
// returned by BlueprintStatus.ValidateAll() if the designated constraints
// aren't met.
type BlueprintStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlueprintStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlueprintStatusMultiError) AllErrors() []error { return m }

// BlueprintStatusValidationError is the validation error returned by
// BlueprintStatus.Validate if the designated constraints aren't met.
type BlueprintStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlueprintStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlueprintStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlueprintStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlueprintStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlueprintStatusValidationError) ErrorName() string { return "BlueprintStatusValidationError" }

// Error satisfies the builtin error interface
func (e BlueprintStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlueprintStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlueprintStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlueprintStatusValidationError{}

// Validate checks the field values on PartDrawingProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PartDrawingProperties) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PartDrawingProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PartDrawingPropertiesMultiError, or nil if none found.
func (m *PartDrawingProperties) ValidateAll() error {
	return m.validate(true)
}

func (m *PartDrawingProperties) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Equipment

	if all {
		switch v := interface{}(m.GetDimension()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PartDrawingPropertiesValidationError{
					field:  "Dimension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PartDrawingPropertiesValidationError{
					field:  "Dimension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDimension()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PartDrawingPropertiesValidationError{
				field:  "Dimension",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDiameter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PartDrawingPropertiesValidationError{
					field:  "Diameter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PartDrawingPropertiesValidationError{
					field:  "Diameter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDiameter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PartDrawingPropertiesValidationError{
				field:  "Diameter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Shape

	// no validation rules for Material

	// no validation rules for SurfaceTreatment

	// no validation rules for Inspection

	// no validation rules for RequestHardness

	// no validation rules for HasCadData

	if len(errors) > 0 {
		return PartDrawingPropertiesMultiError(errors)
	}

	return nil
}

// PartDrawingPropertiesMultiError is an error wrapping multiple validation
// errors returned by PartDrawingProperties.ValidateAll() if the designated
// constraints aren't met.
type PartDrawingPropertiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PartDrawingPropertiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PartDrawingPropertiesMultiError) AllErrors() []error { return m }

// PartDrawingPropertiesValidationError is the validation error returned by
// PartDrawingProperties.Validate if the designated constraints aren't met.
type PartDrawingPropertiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PartDrawingPropertiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PartDrawingPropertiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PartDrawingPropertiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PartDrawingPropertiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PartDrawingPropertiesValidationError) ErrorName() string {
	return "PartDrawingPropertiesValidationError"
}

// Error satisfies the builtin error interface
func (e PartDrawingPropertiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPartDrawingProperties.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PartDrawingPropertiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PartDrawingPropertiesValidationError{}

// Validate checks the field values on Dimension with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Dimension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dimension with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DimensionMultiError, or nil
// if none found.
func (m *Dimension) ValidateAll() error {
	return m.validate(true)
}

func (m *Dimension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetX()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DimensionValidationError{
					field:  "X",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DimensionValidationError{
					field:  "X",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetX()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DimensionValidationError{
				field:  "X",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetY()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DimensionValidationError{
					field:  "Y",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DimensionValidationError{
					field:  "Y",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetY()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DimensionValidationError{
				field:  "Y",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetZ()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DimensionValidationError{
					field:  "Z",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DimensionValidationError{
					field:  "Z",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetZ()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DimensionValidationError{
				field:  "Z",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DimensionMultiError(errors)
	}

	return nil
}

// DimensionMultiError is an error wrapping multiple validation errors returned
// by Dimension.ValidateAll() if the designated constraints aren't met.
type DimensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DimensionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DimensionMultiError) AllErrors() []error { return m }

// DimensionValidationError is the validation error returned by
// Dimension.Validate if the designated constraints aren't met.
type DimensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DimensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DimensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DimensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DimensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DimensionValidationError) ErrorName() string { return "DimensionValidationError" }

// Error satisfies the builtin error interface
func (e DimensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDimension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DimensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DimensionValidationError{}

// Validate checks the field values on AssemblyDrawingProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AssemblyDrawingProperties) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssemblyDrawingProperties with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssemblyDrawingPropertiesMultiError, or nil if none found.
func (m *AssemblyDrawingProperties) ValidateAll() error {
	return m.validate(true)
}

func (m *AssemblyDrawingProperties) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AssemblyDrawingPropertiesMultiError(errors)
	}

	return nil
}

// AssemblyDrawingPropertiesMultiError is an error wrapping multiple validation
// errors returned by AssemblyDrawingProperties.ValidateAll() if the
// designated constraints aren't met.
type AssemblyDrawingPropertiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssemblyDrawingPropertiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssemblyDrawingPropertiesMultiError) AllErrors() []error { return m }

// AssemblyDrawingPropertiesValidationError is the validation error returned by
// AssemblyDrawingProperties.Validate if the designated constraints aren't met.
type AssemblyDrawingPropertiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssemblyDrawingPropertiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssemblyDrawingPropertiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssemblyDrawingPropertiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssemblyDrawingPropertiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssemblyDrawingPropertiesValidationError) ErrorName() string {
	return "AssemblyDrawingPropertiesValidationError"
}

// Error satisfies the builtin error interface
func (e AssemblyDrawingPropertiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssemblyDrawingProperties.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssemblyDrawingPropertiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssemblyDrawingPropertiesValidationError{}

// Validate checks the field values on BlueprintFile with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlueprintFile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlueprintFile with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlueprintFileMultiError, or
// nil if none found.
func (m *BlueprintFile) ValidateAll() error {
	return m.validate(true)
}

func (m *BlueprintFile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AssetId

	// no validation rules for Metadata

	if len(errors) > 0 {
		return BlueprintFileMultiError(errors)
	}

	return nil
}

// BlueprintFileMultiError is an error wrapping multiple validation errors
// returned by BlueprintFile.ValidateAll() if the designated constraints
// aren't met.
type BlueprintFileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlueprintFileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlueprintFileMultiError) AllErrors() []error { return m }

// BlueprintFileValidationError is the validation error returned by
// BlueprintFile.Validate if the designated constraints aren't met.
type BlueprintFileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlueprintFileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlueprintFileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlueprintFileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlueprintFileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlueprintFileValidationError) ErrorName() string { return "BlueprintFileValidationError" }

// Error satisfies the builtin error interface
func (e BlueprintFileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlueprintFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlueprintFileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlueprintFileValidationError{}

// Validate checks the field values on RevisionProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevisionProperties) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevisionProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevisionPropertiesMultiError, or nil if none found.
func (m *RevisionProperties) ValidateAll() error {
	return m.validate(true)
}

func (m *RevisionProperties) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreviousBlueprintId

	// no validation rules for RevisedAt

	if all {
		switch v := interface{}(m.GetOrganizationUnit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RevisionPropertiesValidationError{
					field:  "OrganizationUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RevisionPropertiesValidationError{
					field:  "OrganizationUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrganizationUnit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RevisionPropertiesValidationError{
				field:  "OrganizationUnit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStaff()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RevisionPropertiesValidationError{
					field:  "Staff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RevisionPropertiesValidationError{
					field:  "Staff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStaff()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RevisionPropertiesValidationError{
				field:  "Staff",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Comment

	// no validation rules for ManagementNumber

	if len(errors) > 0 {
		return RevisionPropertiesMultiError(errors)
	}

	return nil
}

// RevisionPropertiesMultiError is an error wrapping multiple validation errors
// returned by RevisionProperties.ValidateAll() if the designated constraints
// aren't met.
type RevisionPropertiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevisionPropertiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevisionPropertiesMultiError) AllErrors() []error { return m }

// RevisionPropertiesValidationError is the validation error returned by
// RevisionProperties.Validate if the designated constraints aren't met.
type RevisionPropertiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevisionPropertiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevisionPropertiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevisionPropertiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevisionPropertiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevisionPropertiesValidationError) ErrorName() string {
	return "RevisionPropertiesValidationError"
}

// Error satisfies the builtin error interface
func (e RevisionPropertiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevisionProperties.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevisionPropertiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevisionPropertiesValidationError{}

// Validate checks the field values on CreateTransactionUnitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionUnitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionUnitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionUnitRequestMultiError, or nil if none found.
func (m *CreateTransactionUnitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionUnitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionUnit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionUnitRequestValidationError{
					field:  "TransactionUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionUnitRequestValidationError{
					field:  "TransactionUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionUnit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionUnitRequestValidationError{
				field:  "TransactionUnit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransactionUnitRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionUnitRequestMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionUnitRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateTransactionUnitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionUnitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionUnitRequestMultiError) AllErrors() []error { return m }

// CreateTransactionUnitRequestValidationError is the validation error returned
// by CreateTransactionUnitRequest.Validate if the designated constraints
// aren't met.
type CreateTransactionUnitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionUnitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionUnitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionUnitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionUnitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionUnitRequestValidationError) ErrorName() string {
	return "CreateTransactionUnitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionUnitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionUnitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionUnitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionUnitRequestValidationError{}

// Validate checks the field values on ListTransactionUnitsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionUnitsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionUnitsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionUnitsRequestMultiError, or nil if none found.
func (m *ListTransactionUnitsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionUnitsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListTransactionUnitsRequestMultiError(errors)
	}

	return nil
}

// ListTransactionUnitsRequestMultiError is an error wrapping multiple
// validation errors returned by ListTransactionUnitsRequest.ValidateAll() if
// the designated constraints aren't met.
type ListTransactionUnitsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionUnitsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionUnitsRequestMultiError) AllErrors() []error { return m }

// ListTransactionUnitsRequestValidationError is the validation error returned
// by ListTransactionUnitsRequest.Validate if the designated constraints
// aren't met.
type ListTransactionUnitsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionUnitsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionUnitsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionUnitsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionUnitsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionUnitsRequestValidationError) ErrorName() string {
	return "ListTransactionUnitsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionUnitsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionUnitsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionUnitsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionUnitsRequestValidationError{}

// Validate checks the field values on ListTransactionUnitsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionUnitsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionUnitsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionUnitsResponseMultiError, or nil if none found.
func (m *ListTransactionUnitsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionUnitsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTransactionUnitsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTransactionUnitsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTransactionUnitsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTransactionUnitsResponseMultiError(errors)
	}

	return nil
}

// ListTransactionUnitsResponseMultiError is an error wrapping multiple
// validation errors returned by ListTransactionUnitsResponse.ValidateAll() if
// the designated constraints aren't met.
type ListTransactionUnitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionUnitsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionUnitsResponseMultiError) AllErrors() []error { return m }

// ListTransactionUnitsResponseValidationError is the validation error returned
// by ListTransactionUnitsResponse.Validate if the designated constraints
// aren't met.
type ListTransactionUnitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionUnitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionUnitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionUnitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionUnitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionUnitsResponseValidationError) ErrorName() string {
	return "ListTransactionUnitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionUnitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionUnitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionUnitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionUnitsResponseValidationError{}

// Validate checks the field values on GetTransactionUnitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionUnitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionUnitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionUnitRequestMultiError, or nil if none found.
func (m *GetTransactionUnitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionUnitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionUnitId

	if len(errors) > 0 {
		return GetTransactionUnitRequestMultiError(errors)
	}

	return nil
}

// GetTransactionUnitRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransactionUnitRequest.ValidateAll() if the
// designated constraints aren't met.
type GetTransactionUnitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionUnitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionUnitRequestMultiError) AllErrors() []error { return m }

// GetTransactionUnitRequestValidationError is the validation error returned by
// GetTransactionUnitRequest.Validate if the designated constraints aren't met.
type GetTransactionUnitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionUnitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionUnitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionUnitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionUnitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionUnitRequestValidationError) ErrorName() string {
	return "GetTransactionUnitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionUnitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionUnitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionUnitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionUnitRequestValidationError{}

// Validate checks the field values on UpdateTransactionUnitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTransactionUnitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTransactionUnitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTransactionUnitRequestMultiError, or nil if none found.
func (m *UpdateTransactionUnitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTransactionUnitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionUnit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTransactionUnitRequestValidationError{
					field:  "TransactionUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTransactionUnitRequestValidationError{
					field:  "TransactionUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionUnit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTransactionUnitRequestValidationError{
				field:  "TransactionUnit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTransactionUnitRequestMultiError(errors)
	}

	return nil
}

// UpdateTransactionUnitRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateTransactionUnitRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateTransactionUnitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTransactionUnitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTransactionUnitRequestMultiError) AllErrors() []error { return m }

// UpdateTransactionUnitRequestValidationError is the validation error returned
// by UpdateTransactionUnitRequest.Validate if the designated constraints
// aren't met.
type UpdateTransactionUnitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTransactionUnitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTransactionUnitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTransactionUnitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTransactionUnitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTransactionUnitRequestValidationError) ErrorName() string {
	return "UpdateTransactionUnitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTransactionUnitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTransactionUnitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTransactionUnitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTransactionUnitRequestValidationError{}

// Validate checks the field values on DeleteTransactionUnitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTransactionUnitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTransactionUnitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTransactionUnitRequestMultiError, or nil if none found.
func (m *DeleteTransactionUnitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTransactionUnitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionUnit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteTransactionUnitRequestValidationError{
					field:  "TransactionUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteTransactionUnitRequestValidationError{
					field:  "TransactionUnit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionUnit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteTransactionUnitRequestValidationError{
				field:  "TransactionUnit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteTransactionUnitRequestMultiError(errors)
	}

	return nil
}

// DeleteTransactionUnitRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteTransactionUnitRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteTransactionUnitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTransactionUnitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTransactionUnitRequestMultiError) AllErrors() []error { return m }

// DeleteTransactionUnitRequestValidationError is the validation error returned
// by DeleteTransactionUnitRequest.Validate if the designated constraints
// aren't met.
type DeleteTransactionUnitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTransactionUnitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTransactionUnitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTransactionUnitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTransactionUnitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTransactionUnitRequestValidationError) ErrorName() string {
	return "DeleteTransactionUnitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTransactionUnitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTransactionUnitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTransactionUnitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTransactionUnitRequestValidationError{}

// Validate checks the field values on CreateBlueprintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBlueprintRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBlueprintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBlueprintRequestMultiError, or nil if none found.
func (m *CreateBlueprintRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBlueprintRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBlueprint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBlueprintRequestValidationError{
					field:  "Blueprint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBlueprintRequestValidationError{
					field:  "Blueprint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlueprint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBlueprintRequestValidationError{
				field:  "Blueprint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateBlueprintRequestMultiError(errors)
	}

	return nil
}

// CreateBlueprintRequestMultiError is an error wrapping multiple validation
// errors returned by CreateBlueprintRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateBlueprintRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBlueprintRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBlueprintRequestMultiError) AllErrors() []error { return m }

// CreateBlueprintRequestValidationError is the validation error returned by
// CreateBlueprintRequest.Validate if the designated constraints aren't met.
type CreateBlueprintRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBlueprintRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBlueprintRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBlueprintRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBlueprintRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBlueprintRequestValidationError) ErrorName() string {
	return "CreateBlueprintRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBlueprintRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBlueprintRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBlueprintRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBlueprintRequestValidationError{}

// Validate checks the field values on ListBlueprintsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBlueprintsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBlueprintsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBlueprintsRequestMultiError, or nil if none found.
func (m *ListBlueprintsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBlueprintsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListBlueprintsRequestMultiError(errors)
	}

	return nil
}

// ListBlueprintsRequestMultiError is an error wrapping multiple validation
// errors returned by ListBlueprintsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListBlueprintsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBlueprintsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBlueprintsRequestMultiError) AllErrors() []error { return m }

// ListBlueprintsRequestValidationError is the validation error returned by
// ListBlueprintsRequest.Validate if the designated constraints aren't met.
type ListBlueprintsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBlueprintsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBlueprintsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBlueprintsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBlueprintsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBlueprintsRequestValidationError) ErrorName() string {
	return "ListBlueprintsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBlueprintsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBlueprintsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBlueprintsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBlueprintsRequestValidationError{}

// Validate checks the field values on ListBlueprintsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBlueprintsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBlueprintsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBlueprintsResponseMultiError, or nil if none found.
func (m *ListBlueprintsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBlueprintsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListBlueprintsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListBlueprintsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListBlueprintsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListBlueprintsResponseMultiError(errors)
	}

	return nil
}

// ListBlueprintsResponseMultiError is an error wrapping multiple validation
// errors returned by ListBlueprintsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListBlueprintsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBlueprintsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBlueprintsResponseMultiError) AllErrors() []error { return m }

// ListBlueprintsResponseValidationError is the validation error returned by
// ListBlueprintsResponse.Validate if the designated constraints aren't met.
type ListBlueprintsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBlueprintsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBlueprintsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBlueprintsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBlueprintsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBlueprintsResponseValidationError) ErrorName() string {
	return "ListBlueprintsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBlueprintsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBlueprintsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBlueprintsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBlueprintsResponseValidationError{}

// Validate checks the field values on GetBlueprintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBlueprintRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBlueprintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBlueprintRequestMultiError, or nil if none found.
func (m *GetBlueprintRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBlueprintRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BlueprintId

	if len(errors) > 0 {
		return GetBlueprintRequestMultiError(errors)
	}

	return nil
}

// GetBlueprintRequestMultiError is an error wrapping multiple validation
// errors returned by GetBlueprintRequest.ValidateAll() if the designated
// constraints aren't met.
type GetBlueprintRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBlueprintRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBlueprintRequestMultiError) AllErrors() []error { return m }

// GetBlueprintRequestValidationError is the validation error returned by
// GetBlueprintRequest.Validate if the designated constraints aren't met.
type GetBlueprintRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBlueprintRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBlueprintRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBlueprintRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBlueprintRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBlueprintRequestValidationError) ErrorName() string {
	return "GetBlueprintRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBlueprintRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBlueprintRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBlueprintRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBlueprintRequestValidationError{}

// Validate checks the field values on UpdateBlueprintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateBlueprintRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateBlueprintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateBlueprintRequestMultiError, or nil if none found.
func (m *UpdateBlueprintRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateBlueprintRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBlueprint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateBlueprintRequestValidationError{
					field:  "Blueprint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateBlueprintRequestValidationError{
					field:  "Blueprint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlueprint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateBlueprintRequestValidationError{
				field:  "Blueprint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateBlueprintRequestMultiError(errors)
	}

	return nil
}

// UpdateBlueprintRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateBlueprintRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateBlueprintRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateBlueprintRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateBlueprintRequestMultiError) AllErrors() []error { return m }

// UpdateBlueprintRequestValidationError is the validation error returned by
// UpdateBlueprintRequest.Validate if the designated constraints aren't met.
type UpdateBlueprintRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateBlueprintRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateBlueprintRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateBlueprintRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateBlueprintRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateBlueprintRequestValidationError) ErrorName() string {
	return "UpdateBlueprintRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateBlueprintRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateBlueprintRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateBlueprintRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateBlueprintRequestValidationError{}

// Validate checks the field values on DeleteBlueprintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBlueprintRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBlueprintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBlueprintRequestMultiError, or nil if none found.
func (m *DeleteBlueprintRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBlueprintRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBlueprint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteBlueprintRequestValidationError{
					field:  "Blueprint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteBlueprintRequestValidationError{
					field:  "Blueprint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlueprint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteBlueprintRequestValidationError{
				field:  "Blueprint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteBlueprintRequestMultiError(errors)
	}

	return nil
}

// DeleteBlueprintRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteBlueprintRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteBlueprintRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBlueprintRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBlueprintRequestMultiError) AllErrors() []error { return m }

// DeleteBlueprintRequestValidationError is the validation error returned by
// DeleteBlueprintRequest.Validate if the designated constraints aren't met.
type DeleteBlueprintRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBlueprintRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBlueprintRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBlueprintRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBlueprintRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBlueprintRequestValidationError) ErrorName() string {
	return "DeleteBlueprintRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBlueprintRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBlueprintRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBlueprintRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBlueprintRequestValidationError{}

// Validate checks the field values on ImportTransactionUnitsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportTransactionUnitsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportTransactionUnitsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ImportTransactionUnitsRequestMultiError, or nil if none found.
func (m *ImportTransactionUnitsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportTransactionUnitsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if all {
		switch v := interface{}(m.GetFileFormat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportTransactionUnitsRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportTransactionUnitsRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFileFormat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportTransactionUnitsRequestValidationError{
				field:  "FileFormat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	// no validation rules for ExportError

	if len(errors) > 0 {
		return ImportTransactionUnitsRequestMultiError(errors)
	}

	return nil
}

// ImportTransactionUnitsRequestMultiError is an error wrapping multiple
// validation errors returned by ImportTransactionUnitsRequest.ValidateAll()
// if the designated constraints aren't met.
type ImportTransactionUnitsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportTransactionUnitsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportTransactionUnitsRequestMultiError) AllErrors() []error { return m }

// ImportTransactionUnitsRequestValidationError is the validation error
// returned by ImportTransactionUnitsRequest.Validate if the designated
// constraints aren't met.
type ImportTransactionUnitsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportTransactionUnitsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportTransactionUnitsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportTransactionUnitsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportTransactionUnitsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportTransactionUnitsRequestValidationError) ErrorName() string {
	return "ImportTransactionUnitsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportTransactionUnitsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportTransactionUnitsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportTransactionUnitsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportTransactionUnitsRequestValidationError{}

// Validate checks the field values on ImportTransactionUnitsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportTransactionUnitsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportTransactionUnitsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ImportTransactionUnitsResponseMultiError, or nil if none found.
func (m *ImportTransactionUnitsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportTransactionUnitsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportTransactionUnitsResponseValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportTransactionUnitsResponseValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportTransactionUnitsResponseValidationError{
				field:  "Summary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportTransactionUnitsResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportTransactionUnitsResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportTransactionUnitsResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AssetId

	if len(errors) > 0 {
		return ImportTransactionUnitsResponseMultiError(errors)
	}

	return nil
}

// ImportTransactionUnitsResponseMultiError is an error wrapping multiple
// validation errors returned by ImportTransactionUnitsResponse.ValidateAll()
// if the designated constraints aren't met.
type ImportTransactionUnitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportTransactionUnitsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportTransactionUnitsResponseMultiError) AllErrors() []error { return m }

// ImportTransactionUnitsResponseValidationError is the validation error
// returned by ImportTransactionUnitsResponse.Validate if the designated
// constraints aren't met.
type ImportTransactionUnitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportTransactionUnitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportTransactionUnitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportTransactionUnitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportTransactionUnitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportTransactionUnitsResponseValidationError) ErrorName() string {
	return "ImportTransactionUnitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportTransactionUnitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportTransactionUnitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportTransactionUnitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportTransactionUnitsResponseValidationError{}

// Validate checks the field values on ExportTransactionUnitsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportTransactionUnitsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportTransactionUnitsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExportTransactionUnitsRequestMultiError, or nil if none found.
func (m *ExportTransactionUnitsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportTransactionUnitsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFileFormat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExportTransactionUnitsRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExportTransactionUnitsRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFileFormat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExportTransactionUnitsRequestValidationError{
				field:  "FileFormat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExportTransactionUnitsRequestMultiError(errors)
	}

	return nil
}

// ExportTransactionUnitsRequestMultiError is an error wrapping multiple
// validation errors returned by ExportTransactionUnitsRequest.ValidateAll()
// if the designated constraints aren't met.
type ExportTransactionUnitsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportTransactionUnitsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportTransactionUnitsRequestMultiError) AllErrors() []error { return m }

// ExportTransactionUnitsRequestValidationError is the validation error
// returned by ExportTransactionUnitsRequest.Validate if the designated
// constraints aren't met.
type ExportTransactionUnitsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportTransactionUnitsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportTransactionUnitsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportTransactionUnitsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportTransactionUnitsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportTransactionUnitsRequestValidationError) ErrorName() string {
	return "ExportTransactionUnitsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExportTransactionUnitsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportTransactionUnitsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportTransactionUnitsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportTransactionUnitsRequestValidationError{}

// Validate checks the field values on ExportTransactionUnitsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportTransactionUnitsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportTransactionUnitsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ExportTransactionUnitsResponseMultiError, or nil if none found.
func (m *ExportTransactionUnitsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportTransactionUnitsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AssetId

	if len(errors) > 0 {
		return ExportTransactionUnitsResponseMultiError(errors)
	}

	return nil
}

// ExportTransactionUnitsResponseMultiError is an error wrapping multiple
// validation errors returned by ExportTransactionUnitsResponse.ValidateAll()
// if the designated constraints aren't met.
type ExportTransactionUnitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportTransactionUnitsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportTransactionUnitsResponseMultiError) AllErrors() []error { return m }

// ExportTransactionUnitsResponseValidationError is the validation error
// returned by ExportTransactionUnitsResponse.Validate if the designated
// constraints aren't met.
type ExportTransactionUnitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportTransactionUnitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportTransactionUnitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportTransactionUnitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportTransactionUnitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportTransactionUnitsResponseValidationError) ErrorName() string {
	return "ExportTransactionUnitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExportTransactionUnitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportTransactionUnitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportTransactionUnitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportTransactionUnitsResponseValidationError{}

// Validate checks the field values on ImportBlueprintsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportBlueprintsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportBlueprintsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportBlueprintsRequestMultiError, or nil if none found.
func (m *ImportBlueprintsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportBlueprintsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if all {
		switch v := interface{}(m.GetFileFormat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportBlueprintsRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportBlueprintsRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFileFormat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportBlueprintsRequestValidationError{
				field:  "FileFormat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	// no validation rules for ExportError

	if len(errors) > 0 {
		return ImportBlueprintsRequestMultiError(errors)
	}

	return nil
}

// ImportBlueprintsRequestMultiError is an error wrapping multiple validation
// errors returned by ImportBlueprintsRequest.ValidateAll() if the designated
// constraints aren't met.
type ImportBlueprintsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportBlueprintsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportBlueprintsRequestMultiError) AllErrors() []error { return m }

// ImportBlueprintsRequestValidationError is the validation error returned by
// ImportBlueprintsRequest.Validate if the designated constraints aren't met.
type ImportBlueprintsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportBlueprintsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportBlueprintsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportBlueprintsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportBlueprintsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportBlueprintsRequestValidationError) ErrorName() string {
	return "ImportBlueprintsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportBlueprintsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportBlueprintsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportBlueprintsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportBlueprintsRequestValidationError{}

// Validate checks the field values on ImportBlueprintsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportBlueprintsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportBlueprintsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportBlueprintsResponseMultiError, or nil if none found.
func (m *ImportBlueprintsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportBlueprintsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportBlueprintsResponseValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportBlueprintsResponseValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportBlueprintsResponseValidationError{
				field:  "Summary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportBlueprintsResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportBlueprintsResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportBlueprintsResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AssetId

	if len(errors) > 0 {
		return ImportBlueprintsResponseMultiError(errors)
	}

	return nil
}

// ImportBlueprintsResponseMultiError is an error wrapping multiple validation
// errors returned by ImportBlueprintsResponse.ValidateAll() if the designated
// constraints aren't met.
type ImportBlueprintsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportBlueprintsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportBlueprintsResponseMultiError) AllErrors() []error { return m }

// ImportBlueprintsResponseValidationError is the validation error returned by
// ImportBlueprintsResponse.Validate if the designated constraints aren't met.
type ImportBlueprintsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportBlueprintsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportBlueprintsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportBlueprintsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportBlueprintsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportBlueprintsResponseValidationError) ErrorName() string {
	return "ImportBlueprintsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportBlueprintsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportBlueprintsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportBlueprintsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportBlueprintsResponseValidationError{}

// Validate checks the field values on ExportBlueprintsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportBlueprintsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportBlueprintsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportBlueprintsRequestMultiError, or nil if none found.
func (m *ExportBlueprintsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportBlueprintsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFileFormat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExportBlueprintsRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExportBlueprintsRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFileFormat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExportBlueprintsRequestValidationError{
				field:  "FileFormat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExportBlueprintsRequestMultiError(errors)
	}

	return nil
}

// ExportBlueprintsRequestMultiError is an error wrapping multiple validation
// errors returned by ExportBlueprintsRequest.ValidateAll() if the designated
// constraints aren't met.
type ExportBlueprintsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportBlueprintsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportBlueprintsRequestMultiError) AllErrors() []error { return m }

// ExportBlueprintsRequestValidationError is the validation error returned by
// ExportBlueprintsRequest.Validate if the designated constraints aren't met.
type ExportBlueprintsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportBlueprintsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportBlueprintsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportBlueprintsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportBlueprintsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportBlueprintsRequestValidationError) ErrorName() string {
	return "ExportBlueprintsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExportBlueprintsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportBlueprintsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportBlueprintsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportBlueprintsRequestValidationError{}

// Validate checks the field values on ExportBlueprintsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportBlueprintsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportBlueprintsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportBlueprintsResponseMultiError, or nil if none found.
func (m *ExportBlueprintsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportBlueprintsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AssetId

	if len(errors) > 0 {
		return ExportBlueprintsResponseMultiError(errors)
	}

	return nil
}

// ExportBlueprintsResponseMultiError is an error wrapping multiple validation
// errors returned by ExportBlueprintsResponse.ValidateAll() if the designated
// constraints aren't met.
type ExportBlueprintsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportBlueprintsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportBlueprintsResponseMultiError) AllErrors() []error { return m }

// ExportBlueprintsResponseValidationError is the validation error returned by
// ExportBlueprintsResponse.Validate if the designated constraints aren't met.
type ExportBlueprintsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportBlueprintsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportBlueprintsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportBlueprintsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportBlueprintsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportBlueprintsResponseValidationError) ErrorName() string {
	return "ExportBlueprintsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExportBlueprintsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportBlueprintsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportBlueprintsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportBlueprintsResponseValidationError{}

// Validate checks the field values on ListTransactionUnitFormatsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListTransactionUnitFormatsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionUnitFormatsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListTransactionUnitFormatsRequestMultiError, or nil if none found.
func (m *ListTransactionUnitFormatsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionUnitFormatsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListTransactionUnitFormatsRequestMultiError(errors)
	}

	return nil
}

// ListTransactionUnitFormatsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListTransactionUnitFormatsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionUnitFormatsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionUnitFormatsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionUnitFormatsRequestMultiError) AllErrors() []error { return m }

// ListTransactionUnitFormatsRequestValidationError is the validation error
// returned by ListTransactionUnitFormatsRequest.Validate if the designated
// constraints aren't met.
type ListTransactionUnitFormatsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionUnitFormatsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionUnitFormatsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionUnitFormatsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionUnitFormatsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionUnitFormatsRequestValidationError) ErrorName() string {
	return "ListTransactionUnitFormatsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionUnitFormatsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionUnitFormatsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionUnitFormatsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionUnitFormatsRequestValidationError{}

// Validate checks the field values on ListTransactionUnitFormatsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListTransactionUnitFormatsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionUnitFormatsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListTransactionUnitFormatsResponseMultiError, or nil if none found.
func (m *ListTransactionUnitFormatsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionUnitFormatsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTransactionUnitFormatsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTransactionUnitFormatsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTransactionUnitFormatsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTransactionUnitFormatsResponseMultiError(errors)
	}

	return nil
}

// ListTransactionUnitFormatsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListTransactionUnitFormatsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionUnitFormatsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionUnitFormatsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionUnitFormatsResponseMultiError) AllErrors() []error { return m }

// ListTransactionUnitFormatsResponseValidationError is the validation error
// returned by ListTransactionUnitFormatsResponse.Validate if the designated
// constraints aren't met.
type ListTransactionUnitFormatsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionUnitFormatsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionUnitFormatsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionUnitFormatsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionUnitFormatsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionUnitFormatsResponseValidationError) ErrorName() string {
	return "ListTransactionUnitFormatsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionUnitFormatsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionUnitFormatsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionUnitFormatsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionUnitFormatsResponseValidationError{}

// Validate checks the field values on ListBlueprintFormatsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBlueprintFormatsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBlueprintFormatsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBlueprintFormatsRequestMultiError, or nil if none found.
func (m *ListBlueprintFormatsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBlueprintFormatsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListBlueprintFormatsRequestMultiError(errors)
	}

	return nil
}

// ListBlueprintFormatsRequestMultiError is an error wrapping multiple
// validation errors returned by ListBlueprintFormatsRequest.ValidateAll() if
// the designated constraints aren't met.
type ListBlueprintFormatsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBlueprintFormatsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBlueprintFormatsRequestMultiError) AllErrors() []error { return m }

// ListBlueprintFormatsRequestValidationError is the validation error returned
// by ListBlueprintFormatsRequest.Validate if the designated constraints
// aren't met.
type ListBlueprintFormatsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBlueprintFormatsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBlueprintFormatsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBlueprintFormatsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBlueprintFormatsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBlueprintFormatsRequestValidationError) ErrorName() string {
	return "ListBlueprintFormatsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBlueprintFormatsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBlueprintFormatsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBlueprintFormatsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBlueprintFormatsRequestValidationError{}

// Validate checks the field values on ListBlueprintFormatsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBlueprintFormatsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBlueprintFormatsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBlueprintFormatsResponseMultiError, or nil if none found.
func (m *ListBlueprintFormatsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBlueprintFormatsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListBlueprintFormatsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListBlueprintFormatsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListBlueprintFormatsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListBlueprintFormatsResponseMultiError(errors)
	}

	return nil
}

// ListBlueprintFormatsResponseMultiError is an error wrapping multiple
// validation errors returned by ListBlueprintFormatsResponse.ValidateAll() if
// the designated constraints aren't met.
type ListBlueprintFormatsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBlueprintFormatsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBlueprintFormatsResponseMultiError) AllErrors() []error { return m }

// ListBlueprintFormatsResponseValidationError is the validation error returned
// by ListBlueprintFormatsResponse.Validate if the designated constraints
// aren't met.
type ListBlueprintFormatsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBlueprintFormatsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBlueprintFormatsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBlueprintFormatsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBlueprintFormatsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBlueprintFormatsResponseValidationError) ErrorName() string {
	return "ListBlueprintFormatsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBlueprintFormatsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBlueprintFormatsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBlueprintFormatsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBlueprintFormatsResponseValidationError{}

// Validate checks the field values on LinkAssetToBlueprintRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LinkAssetToBlueprintRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinkAssetToBlueprintRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LinkAssetToBlueprintRequestMultiError, or nil if none found.
func (m *LinkAssetToBlueprintRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LinkAssetToBlueprintRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetListAssetsRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkAssetToBlueprintRequestValidationError{
					field:  "ListAssetsRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkAssetToBlueprintRequestValidationError{
					field:  "ListAssetsRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetListAssetsRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkAssetToBlueprintRequestValidationError{
				field:  "ListAssetsRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFileFormat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkAssetToBlueprintRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkAssetToBlueprintRequestValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFileFormat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkAssetToBlueprintRequestValidationError{
				field:  "FileFormat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	// no validation rules for ExportError

	if len(errors) > 0 {
		return LinkAssetToBlueprintRequestMultiError(errors)
	}

	return nil
}

// LinkAssetToBlueprintRequestMultiError is an error wrapping multiple
// validation errors returned by LinkAssetToBlueprintRequest.ValidateAll() if
// the designated constraints aren't met.
type LinkAssetToBlueprintRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkAssetToBlueprintRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkAssetToBlueprintRequestMultiError) AllErrors() []error { return m }

// LinkAssetToBlueprintRequestValidationError is the validation error returned
// by LinkAssetToBlueprintRequest.Validate if the designated constraints
// aren't met.
type LinkAssetToBlueprintRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkAssetToBlueprintRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkAssetToBlueprintRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkAssetToBlueprintRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkAssetToBlueprintRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkAssetToBlueprintRequestValidationError) ErrorName() string {
	return "LinkAssetToBlueprintRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LinkAssetToBlueprintRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinkAssetToBlueprintRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkAssetToBlueprintRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkAssetToBlueprintRequestValidationError{}

// Validate checks the field values on LinkAssetToBlueprintResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LinkAssetToBlueprintResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinkAssetToBlueprintResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LinkAssetToBlueprintResponseMultiError, or nil if none found.
func (m *LinkAssetToBlueprintResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LinkAssetToBlueprintResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkAssetToBlueprintResponseValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkAssetToBlueprintResponseValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkAssetToBlueprintResponseValidationError{
				field:  "Summary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkAssetToBlueprintResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkAssetToBlueprintResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkAssetToBlueprintResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AssetId

	if len(errors) > 0 {
		return LinkAssetToBlueprintResponseMultiError(errors)
	}

	return nil
}

// LinkAssetToBlueprintResponseMultiError is an error wrapping multiple
// validation errors returned by LinkAssetToBlueprintResponse.ValidateAll() if
// the designated constraints aren't met.
type LinkAssetToBlueprintResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkAssetToBlueprintResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkAssetToBlueprintResponseMultiError) AllErrors() []error { return m }

// LinkAssetToBlueprintResponseValidationError is the validation error returned
// by LinkAssetToBlueprintResponse.Validate if the designated constraints
// aren't met.
type LinkAssetToBlueprintResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkAssetToBlueprintResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkAssetToBlueprintResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkAssetToBlueprintResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkAssetToBlueprintResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkAssetToBlueprintResponseValidationError) ErrorName() string {
	return "LinkAssetToBlueprintResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LinkAssetToBlueprintResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinkAssetToBlueprintResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkAssetToBlueprintResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkAssetToBlueprintResponseValidationError{}
