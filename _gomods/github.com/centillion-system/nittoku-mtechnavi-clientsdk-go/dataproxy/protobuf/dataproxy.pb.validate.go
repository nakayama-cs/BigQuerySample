// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: dataproxy.proto

package protobuf

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetRecordRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRecordRequestMultiError, or nil if none found.
func (m *GetRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRecord() == nil {
		err := GetRecordRequestValidationError{
			field:  "Record",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRecordRequestValidationError{
				field:  "Record",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TenantId

	if len(errors) > 0 {
		return GetRecordRequestMultiError(errors)
	}

	return nil
}

// GetRecordRequestMultiError is an error wrapping multiple validation errors
// returned by GetRecordRequest.ValidateAll() if the designated constraints
// aren't met.
type GetRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRecordRequestMultiError) AllErrors() []error { return m }

// GetRecordRequestValidationError is the validation error returned by
// GetRecordRequest.Validate if the designated constraints aren't met.
type GetRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRecordRequestValidationError) ErrorName() string { return "GetRecordRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRecordRequestValidationError{}

// Validate checks the field values on IndexFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IndexFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndexFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IndexFilterMultiError, or
// nil if none found.
func (m *IndexFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *IndexFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Operator

	// no validation rules for Value

	if len(errors) > 0 {
		return IndexFilterMultiError(errors)
	}

	return nil
}

// IndexFilterMultiError is an error wrapping multiple validation errors
// returned by IndexFilter.ValidateAll() if the designated constraints aren't met.
type IndexFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndexFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndexFilterMultiError) AllErrors() []error { return m }

// IndexFilterValidationError is the validation error returned by
// IndexFilter.Validate if the designated constraints aren't met.
type IndexFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndexFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndexFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndexFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndexFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndexFilterValidationError) ErrorName() string { return "IndexFilterValidationError" }

// Error satisfies the builtin error interface
func (e IndexFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndexFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndexFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndexFilterValidationError{}

// Validate checks the field values on ListRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRecordsRequestMultiError, or nil if none found.
func (m *ListRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTypeName()) < 1 {
		err := ListRecordsRequestValidationError{
			field:  "TypeName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Limit

	// no validation rules for PageToken

	// no validation rules for TenantId

	// no validation rules for Filter

	if all {
		switch v := interface{}(m.GetUseIndex()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRecordsRequestValidationError{
					field:  "UseIndex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRecordsRequestValidationError{
					field:  "UseIndex",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUseIndex()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRecordsRequestValidationError{
				field:  "UseIndex",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListRecordsRequestMultiError(errors)
	}

	return nil
}

// ListRecordsRequestMultiError is an error wrapping multiple validation errors
// returned by ListRecordsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRecordsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRecordsRequestMultiError) AllErrors() []error { return m }

// ListRecordsRequestValidationError is the validation error returned by
// ListRecordsRequest.Validate if the designated constraints aren't met.
type ListRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRecordsRequestValidationError) ErrorName() string {
	return "ListRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRecordsRequestValidationError{}

// Validate checks the field values on ListRecordsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRecordsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRecordsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRecordsResponseMultiError, or nil if none found.
func (m *ListRecordsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRecordsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRecordsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRecordsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRecordsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListRecordsResponseMultiError(errors)
	}

	return nil
}

// ListRecordsResponseMultiError is an error wrapping multiple validation
// errors returned by ListRecordsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListRecordsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRecordsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRecordsResponseMultiError) AllErrors() []error { return m }

// ListRecordsResponseValidationError is the validation error returned by
// ListRecordsResponse.Validate if the designated constraints aren't met.
type ListRecordsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRecordsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRecordsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRecordsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRecordsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRecordsResponseValidationError) ErrorName() string {
	return "ListRecordsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRecordsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRecordsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRecordsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRecordsResponseValidationError{}

// Validate checks the field values on CreateRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRecordRequestMultiError, or nil if none found.
func (m *CreateRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRecord() == nil {
		err := CreateRecordRequestValidationError{
			field:  "Record",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRecordRequestValidationError{
				field:  "Record",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRecordRequestMultiError(errors)
	}

	return nil
}

// CreateRecordRequestMultiError is an error wrapping multiple validation
// errors returned by CreateRecordRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRecordRequestMultiError) AllErrors() []error { return m }

// CreateRecordRequestValidationError is the validation error returned by
// CreateRecordRequest.Validate if the designated constraints aren't met.
type CreateRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRecordRequestValidationError) ErrorName() string {
	return "CreateRecordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRecordRequestValidationError{}

// Validate checks the field values on UpdateRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRecordRequestMultiError, or nil if none found.
func (m *UpdateRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRecord() == nil {
		err := UpdateRecordRequestValidationError{
			field:  "Record",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRecordRequestValidationError{
				field:  "Record",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRecordRequestMultiError(errors)
	}

	return nil
}

// UpdateRecordRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateRecordRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRecordRequestMultiError) AllErrors() []error { return m }

// UpdateRecordRequestValidationError is the validation error returned by
// UpdateRecordRequest.Validate if the designated constraints aren't met.
type UpdateRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRecordRequestValidationError) ErrorName() string {
	return "UpdateRecordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRecordRequestValidationError{}

// Validate checks the field values on DeleteRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRecordRequestMultiError, or nil if none found.
func (m *DeleteRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRecord() == nil {
		err := DeleteRecordRequestValidationError{
			field:  "Record",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRecordRequestValidationError{
				field:  "Record",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteRecordRequestMultiError(errors)
	}

	return nil
}

// DeleteRecordRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteRecordRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRecordRequestMultiError) AllErrors() []error { return m }

// DeleteRecordRequestValidationError is the validation error returned by
// DeleteRecordRequest.Validate if the designated constraints aren't met.
type DeleteRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRecordRequestValidationError) ErrorName() string {
	return "DeleteRecordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRecordRequestValidationError{}

// Validate checks the field values on CreateRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRecordsRequestMultiError, or nil if none found.
func (m *CreateRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetRecords()) > 500 {
		err := CreateRecordsRequestValidationError{
			field:  "Records",
			reason: "value must contain no more than 500 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateRecordsRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateRecordsRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateRecordsRequestValidationError{
					field:  fmt.Sprintf("Records[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateRecordsRequestMultiError(errors)
	}

	return nil
}

// CreateRecordsRequestMultiError is an error wrapping multiple validation
// errors returned by CreateRecordsRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRecordsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRecordsRequestMultiError) AllErrors() []error { return m }

// CreateRecordsRequestValidationError is the validation error returned by
// CreateRecordsRequest.Validate if the designated constraints aren't met.
type CreateRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRecordsRequestValidationError) ErrorName() string {
	return "CreateRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRecordsRequestValidationError{}

// Validate checks the field values on CreateRecordsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRecordsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRecordsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRecordsResponseMultiError, or nil if none found.
func (m *CreateRecordsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRecordsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateRecordsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateRecordsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateRecordsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateRecordsResponseMultiError(errors)
	}

	return nil
}

// CreateRecordsResponseMultiError is an error wrapping multiple validation
// errors returned by CreateRecordsResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateRecordsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRecordsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRecordsResponseMultiError) AllErrors() []error { return m }

// CreateRecordsResponseValidationError is the validation error returned by
// CreateRecordsResponse.Validate if the designated constraints aren't met.
type CreateRecordsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRecordsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRecordsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRecordsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRecordsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRecordsResponseValidationError) ErrorName() string {
	return "CreateRecordsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRecordsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRecordsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRecordsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRecordsResponseValidationError{}

// Validate checks the field values on UpdateRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRecordsRequestMultiError, or nil if none found.
func (m *UpdateRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetRecords()) > 500 {
		err := UpdateRecordsRequestValidationError{
			field:  "Records",
			reason: "value must contain no more than 500 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateRecordsRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateRecordsRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateRecordsRequestValidationError{
					field:  fmt.Sprintf("Records[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateRecordsRequestMultiError(errors)
	}

	return nil
}

// UpdateRecordsRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateRecordsRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRecordsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRecordsRequestMultiError) AllErrors() []error { return m }

// UpdateRecordsRequestValidationError is the validation error returned by
// UpdateRecordsRequest.Validate if the designated constraints aren't met.
type UpdateRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRecordsRequestValidationError) ErrorName() string {
	return "UpdateRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRecordsRequestValidationError{}

// Validate checks the field values on UpdateRecordsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRecordsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRecordsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRecordsResponseMultiError, or nil if none found.
func (m *UpdateRecordsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRecordsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateRecordsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateRecordsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateRecordsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateRecordsResponseMultiError(errors)
	}

	return nil
}

// UpdateRecordsResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateRecordsResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateRecordsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRecordsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRecordsResponseMultiError) AllErrors() []error { return m }

// UpdateRecordsResponseValidationError is the validation error returned by
// UpdateRecordsResponse.Validate if the designated constraints aren't met.
type UpdateRecordsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRecordsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRecordsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRecordsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRecordsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRecordsResponseValidationError) ErrorName() string {
	return "UpdateRecordsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRecordsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRecordsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRecordsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRecordsResponseValidationError{}

// Validate checks the field values on DeleteRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRecordsRequestMultiError, or nil if none found.
func (m *DeleteRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetRecords()) > 500 {
		err := DeleteRecordsRequestValidationError{
			field:  "Records",
			reason: "value must contain no more than 500 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteRecordsRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteRecordsRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteRecordsRequestValidationError{
					field:  fmt.Sprintf("Records[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteRecordsRequestMultiError(errors)
	}

	return nil
}

// DeleteRecordsRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteRecordsRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRecordsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRecordsRequestMultiError) AllErrors() []error { return m }

// DeleteRecordsRequestValidationError is the validation error returned by
// DeleteRecordsRequest.Validate if the designated constraints aren't met.
type DeleteRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRecordsRequestValidationError) ErrorName() string {
	return "DeleteRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRecordsRequestValidationError{}

// Validate checks the field values on CreateOrUpdateRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateOrUpdateRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrUpdateRecordsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateOrUpdateRecordsRequestMultiError, or nil if none found.
func (m *CreateOrUpdateRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdateRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetRecords()) > 500 {
		err := CreateOrUpdateRecordsRequestValidationError{
			field:  "Records",
			reason: "value must contain no more than 500 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateOrUpdateRecordsRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateOrUpdateRecordsRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateOrUpdateRecordsRequestValidationError{
					field:  fmt.Sprintf("Records[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateOrUpdateRecordsRequestMultiError(errors)
	}

	return nil
}

// CreateOrUpdateRecordsRequestMultiError is an error wrapping multiple
// validation errors returned by CreateOrUpdateRecordsRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateOrUpdateRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdateRecordsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdateRecordsRequestMultiError) AllErrors() []error { return m }

// CreateOrUpdateRecordsRequestValidationError is the validation error returned
// by CreateOrUpdateRecordsRequest.Validate if the designated constraints
// aren't met.
type CreateOrUpdateRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdateRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdateRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdateRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdateRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdateRecordsRequestValidationError) ErrorName() string {
	return "CreateOrUpdateRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdateRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdateRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdateRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdateRecordsRequestValidationError{}

// Validate checks the field values on CreateOrUpdateRecordsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateOrUpdateRecordsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrUpdateRecordsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateOrUpdateRecordsResponseMultiError, or nil if none found.
func (m *CreateOrUpdateRecordsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdateRecordsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateOrUpdateRecordsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateOrUpdateRecordsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateOrUpdateRecordsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateOrUpdateRecordsResponseMultiError(errors)
	}

	return nil
}

// CreateOrUpdateRecordsResponseMultiError is an error wrapping multiple
// validation errors returned by CreateOrUpdateRecordsResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateOrUpdateRecordsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdateRecordsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdateRecordsResponseMultiError) AllErrors() []error { return m }

// CreateOrUpdateRecordsResponseValidationError is the validation error
// returned by CreateOrUpdateRecordsResponse.Validate if the designated
// constraints aren't met.
type CreateOrUpdateRecordsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdateRecordsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdateRecordsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdateRecordsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdateRecordsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdateRecordsResponseValidationError) ErrorName() string {
	return "CreateOrUpdateRecordsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdateRecordsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdateRecordsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdateRecordsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdateRecordsResponseValidationError{}

// Validate checks the field values on StreamRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StreamRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StreamRecordsRequestMultiError, or nil if none found.
func (m *StreamRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTypeName()) < 1 {
		err := StreamRecordsRequestValidationError{
			field:  "TypeName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StreamRecordsRequestMultiError(errors)
	}

	return nil
}

// StreamRecordsRequestMultiError is an error wrapping multiple validation
// errors returned by StreamRecordsRequest.ValidateAll() if the designated
// constraints aren't met.
type StreamRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamRecordsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamRecordsRequestMultiError) AllErrors() []error { return m }

// StreamRecordsRequestValidationError is the validation error returned by
// StreamRecordsRequest.Validate if the designated constraints aren't met.
type StreamRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamRecordsRequestValidationError) ErrorName() string {
	return "StreamRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StreamRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamRecordsRequestValidationError{}

// Validate checks the field values on GetShareRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetShareRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetShareRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetShareRecordRequestMultiError, or nil if none found.
func (m *GetShareRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetShareRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRecord() == nil {
		err := GetShareRecordRequestValidationError{
			field:  "Record",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetShareRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetShareRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetShareRecordRequestValidationError{
				field:  "Record",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetShareRecordRequestMultiError(errors)
	}

	return nil
}

// GetShareRecordRequestMultiError is an error wrapping multiple validation
// errors returned by GetShareRecordRequest.ValidateAll() if the designated
// constraints aren't met.
type GetShareRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetShareRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetShareRecordRequestMultiError) AllErrors() []error { return m }

// GetShareRecordRequestValidationError is the validation error returned by
// GetShareRecordRequest.Validate if the designated constraints aren't met.
type GetShareRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetShareRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetShareRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetShareRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetShareRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetShareRecordRequestValidationError) ErrorName() string {
	return "GetShareRecordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetShareRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetShareRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetShareRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetShareRecordRequestValidationError{}

// Validate checks the field values on ShareRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ShareRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShareRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ShareRecordRequestMultiError, or nil if none found.
func (m *ShareRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ShareRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mode

	if all {
		switch v := interface{}(m.GetRecord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareRecordRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareRecordRequestValidationError{
				field:  "Record",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ShareRecordRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ShareRecordRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ShareRecordRequestValidationError{
					field:  fmt.Sprintf("Records[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ShareRecordRequestMultiError(errors)
	}

	return nil
}

// ShareRecordRequestMultiError is an error wrapping multiple validation errors
// returned by ShareRecordRequest.ValidateAll() if the designated constraints
// aren't met.
type ShareRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShareRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShareRecordRequestMultiError) AllErrors() []error { return m }

// ShareRecordRequestValidationError is the validation error returned by
// ShareRecordRequest.Validate if the designated constraints aren't met.
type ShareRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShareRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShareRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShareRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShareRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShareRecordRequestValidationError) ErrorName() string {
	return "ShareRecordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ShareRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShareRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShareRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShareRecordRequestValidationError{}

// Validate checks the field values on ShareTenant with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ShareTenant) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShareTenant with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ShareTenantMultiError, or
// nil if none found.
func (m *ShareTenant) ValidateAll() error {
	return m.validate(true)
}

func (m *ShareTenant) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for ShareStatus

	// no validation rules for SharedAt

	if len(errors) > 0 {
		return ShareTenantMultiError(errors)
	}

	return nil
}

// ShareTenantMultiError is an error wrapping multiple validation errors
// returned by ShareTenant.ValidateAll() if the designated constraints aren't met.
type ShareTenantMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShareTenantMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShareTenantMultiError) AllErrors() []error { return m }

// ShareTenantValidationError is the validation error returned by
// ShareTenant.Validate if the designated constraints aren't met.
type ShareTenantValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShareTenantValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShareTenantValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShareTenantValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShareTenantValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShareTenantValidationError) ErrorName() string { return "ShareTenantValidationError" }

// Error satisfies the builtin error interface
func (e ShareTenantValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShareTenant.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShareTenantValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShareTenantValidationError{}

// Validate checks the field values on ListSharedTenantsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSharedTenantsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSharedTenantsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSharedTenantsRequestMultiError, or nil if none found.
func (m *ListSharedTenantsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSharedTenantsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRecord() == nil {
		err := ListSharedTenantsRequestValidationError{
			field:  "Record",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListSharedTenantsRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListSharedTenantsRequestValidationError{
					field:  "Record",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListSharedTenantsRequestValidationError{
				field:  "Record",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListSharedTenantsRequestMultiError(errors)
	}

	return nil
}

// ListSharedTenantsRequestMultiError is an error wrapping multiple validation
// errors returned by ListSharedTenantsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListSharedTenantsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSharedTenantsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSharedTenantsRequestMultiError) AllErrors() []error { return m }

// ListSharedTenantsRequestValidationError is the validation error returned by
// ListSharedTenantsRequest.Validate if the designated constraints aren't met.
type ListSharedTenantsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSharedTenantsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSharedTenantsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSharedTenantsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSharedTenantsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSharedTenantsRequestValidationError) ErrorName() string {
	return "ListSharedTenantsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSharedTenantsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSharedTenantsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSharedTenantsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSharedTenantsRequestValidationError{}

// Validate checks the field values on ListSharedTenantsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSharedTenantsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSharedTenantsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSharedTenantsResponseMultiError, or nil if none found.
func (m *ListSharedTenantsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSharedTenantsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetShareTenants() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSharedTenantsResponseValidationError{
						field:  fmt.Sprintf("ShareTenants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSharedTenantsResponseValidationError{
						field:  fmt.Sprintf("ShareTenants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSharedTenantsResponseValidationError{
					field:  fmt.Sprintf("ShareTenants[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListSharedTenantsResponseMultiError(errors)
	}

	return nil
}

// ListSharedTenantsResponseMultiError is an error wrapping multiple validation
// errors returned by ListSharedTenantsResponse.ValidateAll() if the
// designated constraints aren't met.
type ListSharedTenantsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSharedTenantsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSharedTenantsResponseMultiError) AllErrors() []error { return m }

// ListSharedTenantsResponseValidationError is the validation error returned by
// ListSharedTenantsResponse.Validate if the designated constraints aren't met.
type ListSharedTenantsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSharedTenantsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSharedTenantsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSharedTenantsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSharedTenantsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSharedTenantsResponseValidationError) ErrorName() string {
	return "ListSharedTenantsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSharedTenantsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSharedTenantsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSharedTenantsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSharedTenantsResponseValidationError{}

// Validate checks the field values on UnshareRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnshareRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnshareRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnshareRecordRequestMultiError, or nil if none found.
func (m *UnshareRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnshareRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UnshareRecordRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UnshareRecordRequestValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UnshareRecordRequestValidationError{
					field:  fmt.Sprintf("Records[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UnshareRecordRequestMultiError(errors)
	}

	return nil
}

// UnshareRecordRequestMultiError is an error wrapping multiple validation
// errors returned by UnshareRecordRequest.ValidateAll() if the designated
// constraints aren't met.
type UnshareRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnshareRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnshareRecordRequestMultiError) AllErrors() []error { return m }

// UnshareRecordRequestValidationError is the validation error returned by
// UnshareRecordRequest.Validate if the designated constraints aren't met.
type UnshareRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnshareRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnshareRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnshareRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnshareRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnshareRecordRequestValidationError) ErrorName() string {
	return "UnshareRecordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnshareRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnshareRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnshareRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnshareRecordRequestValidationError{}

// Validate checks the field values on AssetData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetDataMultiError, or nil
// if none found.
func (m *AssetData) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AssetDataId

	// no validation rules for SourceUrl

	// no validation rules for Generation

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for DeletedAt

	if all {
		switch v := interface{}(m.GetSharedProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetDataValidationError{
					field:  "SharedProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetDataValidationError{
					field:  "SharedProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSharedProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetDataValidationError{
				field:  "SharedProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AssetDataMultiError(errors)
	}

	return nil
}

// AssetDataMultiError is an error wrapping multiple validation errors returned
// by AssetData.ValidateAll() if the designated constraints aren't met.
type AssetDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetDataMultiError) AllErrors() []error { return m }

// AssetDataValidationError is the validation error returned by
// AssetData.Validate if the designated constraints aren't met.
type AssetDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetDataValidationError) ErrorName() string { return "AssetDataValidationError" }

// Error satisfies the builtin error interface
func (e AssetDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetDataValidationError{}

// Validate checks the field values on GetAssetDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAssetDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAssetDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAssetDataRequestMultiError, or nil if none found.
func (m *GetAssetDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssetDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAssetDataId()) < 1 {
		err := GetAssetDataRequestValidationError{
			field:  "AssetDataId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetAssetDataRequestMultiError(errors)
	}

	return nil
}

// GetAssetDataRequestMultiError is an error wrapping multiple validation
// errors returned by GetAssetDataRequest.ValidateAll() if the designated
// constraints aren't met.
type GetAssetDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssetDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssetDataRequestMultiError) AllErrors() []error { return m }

// GetAssetDataRequestValidationError is the validation error returned by
// GetAssetDataRequest.Validate if the designated constraints aren't met.
type GetAssetDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssetDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssetDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssetDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssetDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssetDataRequestValidationError) ErrorName() string {
	return "GetAssetDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssetDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssetDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssetDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssetDataRequestValidationError{}

// Validate checks the field values on CreateAssetDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAssetDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAssetDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAssetDataRequestMultiError, or nil if none found.
func (m *CreateAssetDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAssetDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAssetData() == nil {
		err := CreateAssetDataRequestValidationError{
			field:  "AssetData",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAssetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAssetDataRequestValidationError{
					field:  "AssetData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAssetDataRequestValidationError{
					field:  "AssetData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAssetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAssetDataRequestValidationError{
				field:  "AssetData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateAssetDataRequestMultiError(errors)
	}

	return nil
}

// CreateAssetDataRequestMultiError is an error wrapping multiple validation
// errors returned by CreateAssetDataRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateAssetDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAssetDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAssetDataRequestMultiError) AllErrors() []error { return m }

// CreateAssetDataRequestValidationError is the validation error returned by
// CreateAssetDataRequest.Validate if the designated constraints aren't met.
type CreateAssetDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAssetDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAssetDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAssetDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAssetDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAssetDataRequestValidationError) ErrorName() string {
	return "CreateAssetDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAssetDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAssetDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAssetDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAssetDataRequestValidationError{}

// Validate checks the field values on DeleteAssetDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAssetDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAssetDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAssetDataRequestMultiError, or nil if none found.
func (m *DeleteAssetDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAssetDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAssetData() == nil {
		err := DeleteAssetDataRequestValidationError{
			field:  "AssetData",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAssetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteAssetDataRequestValidationError{
					field:  "AssetData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteAssetDataRequestValidationError{
					field:  "AssetData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAssetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteAssetDataRequestValidationError{
				field:  "AssetData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteAssetDataRequestMultiError(errors)
	}

	return nil
}

// DeleteAssetDataRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteAssetDataRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteAssetDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAssetDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAssetDataRequestMultiError) AllErrors() []error { return m }

// DeleteAssetDataRequestValidationError is the validation error returned by
// DeleteAssetDataRequest.Validate if the designated constraints aren't met.
type DeleteAssetDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAssetDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAssetDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAssetDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAssetDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAssetDataRequestValidationError) ErrorName() string {
	return "DeleteAssetDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAssetDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAssetDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAssetDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAssetDataRequestValidationError{}

// Validate checks the field values on SignedUrlRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignedUrlRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignedUrlRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignedUrlRequestMultiError, or nil if none found.
func (m *SignedUrlRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SignedUrlRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAssetData() == nil {
		err := SignedUrlRequestValidationError{
			field:  "AssetData",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAssetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignedUrlRequestValidationError{
					field:  "AssetData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignedUrlRequestValidationError{
					field:  "AssetData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAssetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignedUrlRequestValidationError{
				field:  "AssetData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignedUrlRequestMultiError(errors)
	}

	return nil
}

// SignedUrlRequestMultiError is an error wrapping multiple validation errors
// returned by SignedUrlRequest.ValidateAll() if the designated constraints
// aren't met.
type SignedUrlRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignedUrlRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignedUrlRequestMultiError) AllErrors() []error { return m }

// SignedUrlRequestValidationError is the validation error returned by
// SignedUrlRequest.Validate if the designated constraints aren't met.
type SignedUrlRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignedUrlRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignedUrlRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignedUrlRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignedUrlRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignedUrlRequestValidationError) ErrorName() string { return "SignedUrlRequestValidationError" }

// Error satisfies the builtin error interface
func (e SignedUrlRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignedUrlRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignedUrlRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignedUrlRequestValidationError{}

// Validate checks the field values on SignedUrlResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignedUrlResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignedUrlResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignedUrlResponseMultiError, or nil if none found.
func (m *SignedUrlResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SignedUrlResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SignedUrl

	if len(errors) > 0 {
		return SignedUrlResponseMultiError(errors)
	}

	return nil
}

// SignedUrlResponseMultiError is an error wrapping multiple validation errors
// returned by SignedUrlResponse.ValidateAll() if the designated constraints
// aren't met.
type SignedUrlResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignedUrlResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignedUrlResponseMultiError) AllErrors() []error { return m }

// SignedUrlResponseValidationError is the validation error returned by
// SignedUrlResponse.Validate if the designated constraints aren't met.
type SignedUrlResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignedUrlResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignedUrlResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignedUrlResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignedUrlResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignedUrlResponseValidationError) ErrorName() string {
	return "SignedUrlResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SignedUrlResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignedUrlResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignedUrlResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignedUrlResponseValidationError{}

// Validate checks the field values on AuditLog with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuditLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditLog with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuditLogMultiError, or nil
// if none found.
func (m *AuditLog) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for UserId

	// no validation rules for AuditCategory

	// no validation rules for AuditSubCategory

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuditLogValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuditLogValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuditLogValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	// no validation rules for Table

	// no validation rules for RecordId

	// no validation rules for Columns

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return AuditLogMultiError(errors)
	}

	return nil
}

// AuditLogMultiError is an error wrapping multiple validation errors returned
// by AuditLog.ValidateAll() if the designated constraints aren't met.
type AuditLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditLogMultiError) AllErrors() []error { return m }

// AuditLogValidationError is the validation error returned by
// AuditLog.Validate if the designated constraints aren't met.
type AuditLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditLogValidationError) ErrorName() string { return "AuditLogValidationError" }

// Error satisfies the builtin error interface
func (e AuditLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditLogValidationError{}

// Validate checks the field values on ListAuditLogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAuditLogsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAuditLogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAuditLogsRequestMultiError, or nil if none found.
func (m *ListAuditLogsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAuditLogsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for UserId

	if utf8.RuneCountInString(m.GetAuditCategory()) < 1 {
		err := ListAuditLogsRequestValidationError{
			field:  "AuditCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuditSubCategory()) < 1 {
		err := ListAuditLogsRequestValidationError{
			field:  "AuditSubCategory",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Table

	// no validation rules for RecordId

	// no validation rules for From

	// no validation rules for To

	// no validation rules for Limit

	// no validation rules for PageToken

	if len(errors) > 0 {
		return ListAuditLogsRequestMultiError(errors)
	}

	return nil
}

// ListAuditLogsRequestMultiError is an error wrapping multiple validation
// errors returned by ListAuditLogsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListAuditLogsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAuditLogsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAuditLogsRequestMultiError) AllErrors() []error { return m }

// ListAuditLogsRequestValidationError is the validation error returned by
// ListAuditLogsRequest.Validate if the designated constraints aren't met.
type ListAuditLogsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAuditLogsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAuditLogsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAuditLogsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAuditLogsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAuditLogsRequestValidationError) ErrorName() string {
	return "ListAuditLogsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAuditLogsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAuditLogsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAuditLogsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAuditLogsRequestValidationError{}

// Validate checks the field values on ListAuditLogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAuditLogsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAuditLogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAuditLogsResponseMultiError, or nil if none found.
func (m *ListAuditLogsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAuditLogsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAuditLogsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAuditLogsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAuditLogsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListAuditLogsResponseMultiError(errors)
	}

	return nil
}

// ListAuditLogsResponseMultiError is an error wrapping multiple validation
// errors returned by ListAuditLogsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListAuditLogsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAuditLogsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAuditLogsResponseMultiError) AllErrors() []error { return m }

// ListAuditLogsResponseValidationError is the validation error returned by
// ListAuditLogsResponse.Validate if the designated constraints aren't met.
type ListAuditLogsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAuditLogsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAuditLogsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAuditLogsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAuditLogsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAuditLogsResponseValidationError) ErrorName() string {
	return "ListAuditLogsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAuditLogsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAuditLogsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAuditLogsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAuditLogsResponseValidationError{}
